Pyth reference and documentation

Types:

num = int, float
cmp = complex
seq = str, list, tuple
lst = list, tuple
idx = str, list, dict
col = str, list, set, dict
any = any expression
smt = any series of statements
... = any number of arguments.
n _ = n _ arguments.
var = variable. Not evaluated.
func = function. Not evaluated.
func n = function with arity n.
pfn = Preceding function of arity n. *F, for instance.
l _ = Lambda with lambda variable(s) _
i>0 = positive int.
i>=0 = nonnegative int.
i<0 = negative int.
none = missing argument.

Shorthands:
In the text, A refers to the first argument, B to the second, etc.
If two type definitions overlap, more specific takes precedence.
No operations modify the input unless specifically specified.
x -> y -> z -> ... means on future / nested uses, the successive character is used. If there is an extra -> at the end, it is cyclic.

Format:
Token | Input types | Effect

0                         Leading 0 is a separate token, number zero.
0123456789.               Numeric literals. Leading 0 ignored, trailing . often ignored.
\n <any>                  Print with trailing newline. Return input.
   <any>                  Identity function. Suppresses printing.
!  <any>                  Logical negation. 0, 0.0, "", [], (), {}, set() -> True, else False.
"                         Begin and end string literal.
#                         Loop until error statement. On error, suppress and break out of loop.
$                         Begin and end Python literal. Counts as one token. Disabled in -s (online).
%  <num> <num>            Modulo. Same as Python.
%  <int> <seq>            Every Ath element of B. B[::A] in Python.
%  <str> <lst>            Format string, B is list of arguments. % in Python.
%  <str> <any>            Format string, B is only argument.
%  <cmp> <num>            Apply modulo to real and imaginary parts separately.
&  <any> <any>            If not A, return A. Else, return B. Short-circuiting. Same as Python and.
'  <str>                  Open the file or website given by the input string. Return list of lines if normal file or website. Return list of color triples for color images, and list of brightness values for grayscale images.
(  <any...>               Tuple constructor. tuple(A) in Python.
)                         End function or statement.
*  <num> <num>            Multiplication. * in Python.
*  <num> <seq>            Repetition. * in Python.
*  <seq> <num>            Repetition. * in Python.
*  <col> <col>            Cartesian product. All pairs of A_elem, B_elem.
+  <num> <num>            Addition. + in Python.
+  <str> <str>            Concatenate. + in Python.
+  <lst> <lst>            Concatenate. + in Python (But cast to list).
+  <lst> <any>            Append B to the end of A.
+  <any> <lst>            Prepend A to the beginning of B.
+  <str> <num>            Append str(B) to the end of A.
+  <num> <str>            Prepend str(A) to the beginning of B.
+  <set> <col>            Union of A and B.
+  <set> <any>            Union of A and {B}.
,  <any> <any>            [A, B]
-  <num> <num>            Subtraction. - in Python.
-  <col> <col>            Filter A on absence from b. Uses not in.
-  <num> <col>            Cast A to B's type, then filter on absence.
-  <col> <num>            Cast B to A's type, then filter on absence.
/  <num> <num>            Integer division. // in Python.
/  <lst> <any>            Count occurrences of B in A.
/  <str> <str>            Count occurrences of B in A.
:  <seq> <int> <int>      Slice of A from B to C. A[B:C] in Python.
:  <num> <num> <num>      Stepped range. Go from A to B with a step size of C.
:  <idx> <col> <col>      Multiple assignment. For i in B, A[i] = C[i], If C runs out, it repeats.
:  <idx> <col> <num>      Multiple assignment. For i in B, A[i] = C.
:  <str> <str> <str>      Regex substitution. In A, replace B with C.
:  <str> <str> 0 or )     Regex search boolean. In A, return whether a match for B is found.
:  <str> <str> 1          Regex search. In A, return every match for B (non overlapping)
:  <str> <str> 2          In A, replace each match of regex B with its first capturing group.
:  <str> <str> 3          Split A on matches of regex B. Retain capturing groups.
:  <str> <str> 4          Return list of match and all capturing groups for each match of B in A.
;                         End all containing functions, statements, etc.
<  <num> <num>            Less than, numeric.
<  <str> <str>            Less than, lexicographic.
<  <lst> <lst>            Less than, lexicographic.
<  <seq> <num>            First B elements of A. A[:B] in Python.
<  <num> <seq>            All but last A elements of B. B[:len(B)-A] in Python.
<  <cmp> <num>            Less than, absolute value/magnitude.
<  <num> <cmp>            Less than, absolute value/magnitude.
<  <set> <col>            Proper subset.
=  <var> <any>            Assign A value B. deepcopy value before assignment.
=  <func> <var> <...>     Assign B value A(B,C,..). The Python Y += 3 would be =+Y3.
>  <num> <num>            Greater than, numeric.
>  <str> <str>            Greater than, lexicographic.
>  <lst> <lst>            Greater than, lexicographic.
>  <seq> <num>            A at and after index B. A[B:] in Python.
>  <num> <seq>            Last A elements of B. B[len(B)-A:] in Python.
>  <cmp> <num>            Greater than, absolute value/magnitude.
>  <num> <cmp>            Greater than, absolute value/magnitude.
>  <set> <col>            Proper superset.
?  <any> <any> <any>      Ternary. A ? B : C in C-like languages. B if A else C in Python.
@  <seq> <num>            Index into the sequence. Modular wrapping. A[B % len(A)] in Python.
@  <dict> <any>           Index into the dict. A[B] in Python.
@  <col> <col>            Intersection. Filter B on presence in A.
@  <num> <num>            Root. A ** (1/B) in Python.
A  <list, 2 elements>     Assign the first value of the list to G and the second to H. Return the input.
B                         Break. Ends surrounding statement.
B  <pfn> <any> <n-1 any>  Bifurcate. Return two element list [B, A(B, ...)].
C  <int>                  Character with code point A. If A is too large, convert to base 256 and turn each into a character.
C  <float>                C(floor(A))
C  <cmp>                  Complex conjugate.
C  <str>                  Convert A to int using base 256 and code points.
C  <col>                  Matrix transpose, truncating to the length of the shortest entry.
D  <func n> <n var> <smt> Define a function. Same as def A(B...) in Python.
E                         Evaluate input. Same as ast.literal_eval(input()) in Python.
F  <var> <num> <smt>      For A in range(int(B)): C
F  <var> <any> <smt>      For A in B: C
G                         Variable. Initialized to "abcdefghijklmnopqrstuvwxyz".
H                         Variable. Initialized to {}. (Hash table)
I  <ant> <smt>            if A: B
I  <pfn> <any> <n-1 any>  Invariant. A(B, ...) == B.
J  <any>                  Variable, Autoinitializing. J=A on first use.
J                         Variable. Second use and later.
K  <any>                  Variable, Autoinitializing. K=A on first use.
K                         Variable.  Second use and later.
L  <any>                  def y(b): return A. y -> ' ->
L  <pfn> <n-1 any> <col>  Left map. n>=2. Map A(B, ..., _) over C, where _ is the lambda variable. Map uses m underneath, and B may refer to its lambda variable.
M  <any>                  def g(G,H): return A. g -> n ->
M <pfn> <col>             Map. Map A(_) over B, where _ is the lambda variable. Map uses m underneath, and B may refer to its lambda variable.
N                         Variable. Initialized to '"'.
O  <int>                  If A > 0, random int below A. If A == 0, random float 0 to 1. If A < 0, random.seed(-A).
O  <col>                  Random element of A.
P  <i>=0>                 List of prime factors of A with multiplicity in increasing order. Uses sympy if sympy is installed, trial division otherwise. Empty list if A is 0 or 1.
P  <i<0>                  Returns whether -A is prime.
P  <num>                  Complex phase of A.
P  <seq>                  All but the last element of A. A[:-1] in Python.
Q                         Variable, Autoinitialized to eval(input()).
R  <any>                  Return, used inside D.
R  <pfn> <n-1 any> <col>  Right map. n >= 2. Map A(_, B, ...) over C, where _ is the lambda variable. Map uses m underneath, and B may refer to its lambda variable.
S  <col>                  Sort. sorted(A) in Python.
S  <int>                  1-indexed range. [1, 2, ... A].
S  <num>                  1-indexed range up to floor of A.
T                         Variable. Initialized to 10. (Ten)
U  <i>=0>                 Unary range. [0, 1, ... A-1]. range(A) in Python.
U  <i<0>                  Reversed unary range. [A, A+1, ... -1]. range(A, 0) in Python.
V  <num> <stmt>           Shorthand for 'FNU'. N -> H -> b ->
V  <col> <stmt>           Shorthand for 'FN'. N -> H -> b ->
W  <any> <stmt>           While loop. while A: B in Python.
W  <pfn> <any> <any> <n-1 any> Conditional application. If B, A(C, ...). Else, C.
X  <dict> <list> <any>    Dictionary assignment. A[tuple(B)] = C in Python.
X  <dict> <any> <any>     Dictionary assignment. A[B] = C
X  <str> <int> <any>      String assignment. Replace in A at index B with str(C). Modular indexing.
X  <seq> <int> <any>      Sequence assignment. Replace in A at index B with C. Modular indexing.
X  <seq> <seq> <seq>      Translate A from B to C. Modular indexing.
X  <seq> <seq> <none>     Translate A from B to B[::-1].
X  <int> <list> <any>     In-place +=. B[A] += C. Modular indexing.
X  <list> <dict> <any>    B[tuple(A)] += C, or B[tuple(A)] = C if tuple(A) not in B.
X  <any> <dict> <any>     B[A] += C, or B[A] = C if A not in B.
X  <int> <str> <any>      Insert into string. Insert str(C) into B at A.
Y                         Variable. Initialized to [].
Z                         Variable. Initialized to 0. (zero)
[  <any...>               List constructor. list(A) in Python.
\  <char>                 One character string.
]  <any>                  [A].
^  <num> <num>            Exponentiation. A ** B in Python.
^  <col> <int>            Repeated Cartesian Product. itertools.product(A, repeat=B) in Python.
_  <num>                  Negation. -A in Python.
_  <seq>                  Reversal. A[::-1] in Python.
_  <dict>                 Swap keys and values.
`  <any>                  Representation. repr in Python.
a  <list> <any>           Append. A.append(B) in Python. Return A.
a  <set> <any>            Add. A.add(B) in Python. return A.
b                         Variable. Initialized to '\n'.
c  <num> <num>            Float division. A / B in Python.
c  <str> <str>            Split. A.split(B) in Python.
c  <str> <none>           Split on whitespace. A.split() in Python.
c  <str> <int>            Chop A into pieces of length B. Last shorter if necessary.
c  <int> <str>            Chop A into B pieces of equal sizes, initial pieces one longer if necessary.
c  <seq> <col of ints>    Chop A at every location in B.
c  <seq> <any>            Chop A at every occurrence of B.
d                         Variable. Initialized to ' '.
e  <seq>                  End. A[-1] in Python.
e  <cmp>                  Imaginary part. A.imag in Python.
e  <num>                  Last digit. A % 10 in Python.
f  <l T> <col>            Filter A(_) over B. T -> Y -> Z ->
f  <l T> <num>            First input where A(_) is truthy over [B, B+1, B+2, ...]
f  <l T> <none>           First input where A(_) is truthy over [1, 2, 3, 4...]
g  <num> <num>            Greater than or equal. A >= B in Python.
g  <seq> <seq>            Greater than or equal. A >= B in Python.
g  <set> <col>            Superset. A.issuperset(B)
g  <seq> <num>            Inclusive slice. A[B-1:] in Python.
h  <seq>                  Head. A[0] in Python.
h  <num>                  A + 1.
i  <str> <int>            Convert A from base B to int. if A is '', return 0. int(A, B) in Python.
i  <seq> <num>            Convert A from base B to int.
i  <int> <int>            GCD.
j  <int> <int>            Convert A to base B as a list.
j  <str> <col>            Join B on A. Convert elements of B to strings if needed.
j  <col> <none>           Join A on newlines.
j  <any> <col>            Join B on A. Convert A to a string, elements of B to strings.
l  <col>                  len(A).
l  <num>                  log base 2 of A.
m  <l d> <col>            Map A(_) over B. d -> k -> b ->
m  <l d> <num>            Map A(_) over U(B). (U is the Pyth function)
n  <any> <any>            A != B
o  <l N> <col>            Sort B with key function A. sorted(B, key=A) in Python.
o  <l N> <num>            Same, but U(B).
p  <any>                  Print A, with no trailing newline. Return A.
q  <any> <any>            A == B
r  <str> 0                A.lower()
r  <str> 1                A.upper()
r  <str> 2                A.swapcase()
r  <str> 3                A.title()
r  <str> 4                A.capitalize()
r  <str> 5                string.capwords(A)
r  <str> 6                A.strip() - Remove whitespace on both sides of A.
r  <str> 7                Split A, eval each part.
r  <seq> 8                Run length encode A. Output format [[3, 'a'], [2, 'b'], [1, 'c'], [1, 'd']].
r  <str> 9                Run length decode A. Input format '3a2bcd' -> 'aaabbcd'
r  <seq> 9                Run length decode A. Input format [[3, 'a'], [2, 'b'], [1, 'c'], [1, 'd']].
r  <int> <int>            Range, half inclusive. range(A, B) in Python, or range(A, B, -1).
r  <str> <str>            String range. r(C(A), C(B)), then convert each int to string using C.
s  <col of str>           Concatenate. ''.join(A)
s  <col>                  reduce on +. (Pyth +)
s  []                     0
s  <cmp>                  Real part. A.real in Python.
s  <num>                  Floor to int. int(A) in Python.
s  <str>                  Parse as int. int(A) in Python.
s  ""                     0
t  <num>                  A - 1.
t  <seq>                  Tail. A[1:] in Python.
